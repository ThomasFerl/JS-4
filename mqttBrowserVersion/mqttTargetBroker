const aedes       = require('aedes')(); // MQTT-Broker-Instanz
const server      = require('net').createServer(aedes.handle);
const sqlite3     = require('sqlite3').verbose();
const TARGET_PORT = 4701; // Port für den Target-Broker
const TARGET_DB   = './mqtt_RawValues.db'; // SQLite-Datenbank für die Rohdaten 

const db = new sqlite3.Database( TARGET_DB , (err) => {
    if (err) console.error('Fehler beim Verbinden mit der Datenbank:', err.message);
    else     console.log('Verbunden mit der SQLite-Datenbank "'+TARGET_DB+'"');
});

// Prüft, ob die Tabellen existieren, und erstellt sie bei Bedarf.
setupDatabase();


// Starte den MQTT-Broker
server.listen(TARGET_PORT, () => { console.log(`Target-Broker läuft auf Port ${TARGET_PORT}`); });

// Ereignis: Client verbindet sich
aedes.on('client', (client) => {console.log(`Client verbunden: ${client.id}`);});

// Ereignis: Client trennt sich
aedes.on('clientDisconnect', (client) => {console.log(`Client getrennt: ${client.id}`);});

// Ereignis: Nachricht empfangen
aedes.on('publish', (packet, client) => { 
                                          console.log(`Nachricht empfangen: ${packet.topic} -> ${packet.payload.toString()}`); 
                                          handleTopic(packet.topic, packet.payload.toString()); 
                                        });

//--------------------------------------------------------------------------------------------------------------------------------------

function handleTopic( topic, payload)
 {
    // 1. Prüfen, ob das Topic existiert
    db.get('SELECT ID FROM mqttTopics WHERE topic = ?', [topic], (err, row) => {
                                                  if (err) { console.error('Fehler beim Prüfen des Topics:', err.message); return; }
                                                 
                                                  if (row) { safePayload(row.ID, payload); }
                                                  else {
                                                          // Topic ist neu -> füge es hinzu und gib die neue ID zurück
                                                          db.run('INSERT INTO mqttTopics (topic) VALUES (?)', [topic], function (err) {
                                                             if (err) { console.error('Fehler beim Prüfen des Topics:', err.message); return; }
                                                             safePayload(this.lastID, payload);  
                                                          });
                                                       }
                                              });
}



// payload-example:
//  {"source":"analog","id":2,"type":"float","name":"PT500_IT-Werkstatt","timestamp":"2025-01-21-16:12:17","value":21.1,"unit":"°C"}

// Datumswandung von yyyy-mm-dd-hh:mn:ss in Excel-Zeit
function toExcelDate(dateString) 
{
    var parts = dateString.split("-");
    if (parts.length > 3) {
        parts[2] += "T" + parts[3];
        parts.splice(3, 1); // Entfernt den vierten Teil (jetzt überflüssig)
        dateString = parts.join("-");
    }
    // Wandelt das Datum in einen Unix-Timestamp um (ms seit 1970)
    const date = new Date(dateString);
    const unixTimestamp = date.getTime() / 1000; // in Sekunden

    // Unix-Timestamp in Excel-Datum umrechnen
    const daysSinceUnixEpoch = unixTimestamp / 86400; // Sekunden in Tage
    var excelDate = daysSinceUnixEpoch + 25569; // Differenz zu Excel-Datum
        excelDate = excelDate + (1/24); // Zeitzone: 1 Stunde

    return (Math.round(excelDate*1000)/1000);
}

function safePayload( ID_topic, payload)
{
    try { var p = JSON.parse(payload); }
    catch (e) { console.error('Fehler beim Parsen der Payload:', e.message); return; }

    // 2. Speichere die Payload in der Tabelle mqttRawValues
    db.run('INSERT INTO mqttPayloads (ID_topic, source  , mqttid , name   , timestamp   , value   , unit ) VALUES (?, ?, ?, ?, ?, ?, ?)', 
                                     [ID_topic, p.source, p.id   , p.name , toExcelDate(p.timestamp) , p.value , p.unit ], function(err){
                                     if (err) { console.error('Fehler beim Speichern der Payload:', err.message); return; }
                                     console.log(`Payload gespeichert  => ID: ${this.lastID}`);
    });
}





//Prüft, ob die Tabellen existieren, und erstellt sie bei Bedarf.

function setupDatabase() 
{
    // Tabelle mqttTopics erstellen, falls sie nicht existiert
    const createTopicsTable = `
        CREATE TABLE IF NOT EXISTS mqttTopics (
            ID INTEGER PRIMARY KEY AUTOINCREMENT,
            topic TEXT UNIQUE NOT NULL
        )
    `;
    db.run(createTopicsTable, (err) => {
        if (err) {
            console.error('Fehler beim Erstellen der Tabelle mqttTopics:', err.message);
        } else {
            console.log('Tabelle mqttTopics überprüft/erstellt.');
        }
    });

    // Tabelle mqttMessages erstellen, falls sie nicht existiert
    const createMessagesTable = `
        CREATE TABLE IF NOT EXISTS mqttPayloads (
            ID INTEGER PRIMARY KEY AUTOINCREMENT,
            ID_topic INTEGER NOT NULL,
            source TEXT ,
            mqttid INTEGER ,
            name TEXT ,
            timestamp TEXT ,
            exceltime REAL ,
            value REAL,
            unit TEXT 
        )
    `;
    db.run(createMessagesTable, (err) => {
        if (err) {
            console.error('Fehler beim Erstellen der Tabelle mqttMessages:', err.message);
        } else {
            console.log('Tabelle mqttMessages überprüft/erstellt.');
        }
    });
}


/*

Stunden-Aggregation:
SELECT exceltime , AVG/SUM/MAX/MIN(value) as value
FROM mqttPayloads
GROUP BY CAST(exceltime*24 AS INTEGER);

Tages-Aggregation:
SELECT exceltime , AVG/SUM/MAX/MIN(value) as value
FROM mqttPayloads
GROUP BY ROUND(exceltime);

Monats-Aggregation: 
SELECT exceltime , AVG/SUM/MAX/MIN(value) as value
FROM mqttPayloads
GROUP BY strftime('%Y-%m', datetime((exceltime - 25569) * 86400, 'unixepoch'));

Jahres-Aggregation: 
SELECT exceltime , AVG/SUM/MAX/MIN(value) as value
FROM mqttPayloads
GROUP BY strftime('%Y', datetime((exceltime - 25569) * 86400, 'unixepoch'));


Archivierung in Stunden-Werten:
INSERT INTO mqttArchive_hour (ID_Topic,source,mqttid,name,dt,value,unit)
SELECT 
    ID_Topic, 
    source, 
    mqttid, 
    name,
    CAST(exceltime * 24 AS INTEGER) / 24.0 , 
    AVG/SUM/MIN/MAX(value) ,
    unit
FROM mqttPayloads 
GROUP BY ID_Topic, 
         source, 
         mqttid, 
         name,
         CAST(exceltime * 24 AS INTEGER) / 24.0 , 
         AVG/SUM/MIN/MAX(value) ,
         unit
*/



// Die Archivierung als stündlicher Job
function doArchive() 
{
    console.log("Starte Archivierungsroutine...");

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");

        // Aggregation und Einfügen in die Archiv-Tabelle
        db.run(`
                INSERT INTO mqttArchive_hour (ID_Topic,source,mqttid,name,dt,value,unit)
                SELECT 
                ID_Topic, 
                source, 
                mqttid, 
                name,
                CAST(exceltime * 24 AS INTEGER) / 24.0 , 
                AVG/SUM/MIN/MAX(value) ,
                unit
                FROM mqttPayloads 
                GROUP BY ID_Topic, 
                         source, 
                         mqttid, 
                         name,
                         CAST(exceltime * 24 AS INTEGER) / 24.0 , 
                         AVG/SUM/MIN/MAX(value) ,
                         unit
        `, function (err) {
            if (err) {
                console.error("Fehler beim Einfügen in die Archiv-Tabelle:", err.message);
                return db.run("ROLLBACK");
            }
        });

        // Löschen der verarbeiteten Daten
        db.run(`
            DELETE FROM mqttPayloads
            WHERE exceltime < (strftime('%s', 'now', 'localtime') / 86400.0)
        `, function (err) {
            if (err) {
                console.error("Fehler beim Löschen aus mqttPayloads:", err.message);
                return db.run("ROLLBACK");
            }
        });

        db.run("COMMIT", (err) => {
            if (!err) {
                console.log("Archivierungsroutine erfolgreich abgeschlossen.");
            }
        });
    });
}

// Routine alle 60 Minuten ausführen
setInterval(doArchive, 60 * 60 * 1000);



